// Nathan Wingert - u0687928
// Image Processing Library Test Source
// Converting to pixels, testing

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include "ImProc.h"

struct pixel* Invert_Pixels(struct pixel* image, int width, int height)
{
  int i = 0;      
  int length = width * height;

  for(i; i < length; i++)
    {
      pixel p = image[i];
      p.red = 255 - p.red;
      p.green = 255 - p.green;
      p.blue = 255 - p.blue;
      image[i] = p;
    }
  return image;
}

struct pixel* Modify_Brightness(struct pixel* image, int alpha, int width, int height)
{
  int i = 0;
  int length = width * height;

  for(i; i < length; i++)
    {
      // compute new pixel data
      pixel p = image[i];
      p.red = p.red * alpha;
      p.green = p.green * alpha;
      p.blue = p.blue * alpha;
      
      // clamp pixel data to 0/255 (assuming 8 bit depth)
      p.red = p.red + alpha;
      p.green = p.green + alpha;
      p.blue = p.blue + alpha;
      
      // clamp pixel data to 0/255 (assuming 8 bit depth)
      p.red = (p.red > 255) ? 255 : p.red;
      p.green = (p.green > 255) ? 255 : p.green;
      p.blue = (p.blue > 255) ? 255 : p.blue;

      image[i] = p;
    }
  return image;
}

struct pixel* Modify_Contrast(struct pixel* image, int alpha, int width, int height)
{
  int i = 0;
  int length = width * height;

  for(i; i < length; i++)
    {
      // compute new pixel data
      pixel p = image[i];
      p.red = p.red * alpha;
      p.green = p.green * alpha;
      p.blue = p.blue * alpha;
      
      // clamp pixel data to 0/255 (assuming 8 bit depth)
      p.red = p.red * alpha;
      p.green = p.green * alpha;
      p.blue = p.blue * alpha;
      
      // clamp pixel data to 0/255 (assuming 8 bit depth)
      p.red = (p.red > 255) ? 255 : p.red;
      p.green = (p.green > 255) ? 255 : p.green;
      p.blue = (p.blue > 255) ? 255 : p.blue;

      image[i] = p;
    }
  return image;
}

struct pixel* Threshold(struct pixel* image, int alpha, int width, int height)
{
  int i = 0;
  int length = width * height;

  for(i; i < length; i++)
    {
      // compute new pixel data
      pixel p = image[i];
      
      // clamp pixel data to 0/255 (assuming 8 bit depth)
      p.red = (p.red > alpha) ? 255 : 0;
      p.green = (p.green > alpha) ? 255 : 0;
      p.blue = (p.blue > alpha) ? 255 : 0;

      // assign new pixel info
      image[i] = p;
    }
  return image;
}

struct pixel* Gamma_Corr(struct pixel* image, double alpha,  int width, int height)
{
  int i, a;
  i = a = 0;
  int length = width * height;

  int K = 256;
  int aMax = K - 1;
  double GAMMA = alpha;
  
  short lookupTable[K];

  // compute lookup table
  for(a = 0; a < K; a++)
    {
      double aa = (double) a / aMax;
      double bb = pow(aa, GAMMA);

      short b = (short) round(bb * aMax);
      lookupTable[a] = b;
    }

  pixel p;
  for(i; i < length; i++)
    {
      // apply lookup table to image
      p = image[i];
      p.red = lookupTable[p.red];
      p.green = lookupTable[p.green];
      p.blue = lookupTable[p.blue];
      image[i] = p;
    }
  return image;
}

struct pixel* Auto_Contrast(struct pixel* image, int width, int height)
{
  int i;
  unsigned char r_low, r_high, g_low, g_high, b_low, b_high;
  i = r_low = r_high = g_low = g_high = b_low = b_high = 0;
  int length = width * height;

  unsigned long** histogram = (long**)malloc(3*sizeof(long*));
  for(i = 0; i < 3; i++)
    {
      histogram+i = (long*)malloc(256*sizeof(long));
    }

  for(i = 0; i < 256; i++)
    {
      histogram[0][i] = 0;
      histogram[1][i] = 0;
      histogram[2][i] = 0;
    }
  Histogram(image, width, height, histogram);
 
  // get low value
  i = 0;
  while(a_low == 0){
    if(histogram[i] != 0) a_low = i;
    i++;
  }

  // get high value
  i = 0;
  while(a_high == 0){
    if(histogram[255-i] != 0) a_high = 255-i;
    i++;
  }

  for(i = 0; i < length; i++)
    {
      // compute new pixel data
      short newPixel = image[i] - a_low;
      newPixel = newPixel * (255.0/(a_high-a_low));
      image[i] = newPixel;
    }

  free(histogram);
  return image;
}

unsigned short* Histogram_Eq(unsigned short* image, int width, int height)
{
  int i;
  int length = width * height;
 
  unsigned long* histogram = malloc(256*sizeof(long));
  for(i = 0; i < 256; i++)
      histogram[i] = 0;
  Cum_Histogram(image, width, height, histogram);

  for(i = 0; i < length; i++)
    {
      image[i] = round(histogram[image[i]] * (255.0/length));
    }

  return image;
}


// analysis

unsigned long** Histogram(struct pixel* image, int width, int height, unsigned long** histogram)
{
  int i = 0;
  int length = width * height;

  for(i; i < length; i++)
    {
      pixel p = image[i];

      // get pixel values
      int red = p.red;
      int green = p.green;
      int blue = p.blue;

      histogram[0][red] = histogram[0][red] + 1;
      histogram[1][green] = histogram[1][green] + 1;
      histogram[2][blue] = histogram[2][blue] + 1;
    }
  return histogram;
}

unsigned long** Cum_Histogram(struct pixel* image, int width, int height, unsigned long** histogram)
{
  int i;
  int length = width * height;

  Histogram(image, width, height, histogram);

  for(i = 1; i < 255; i++)
    {
      histogram[0][i] = histogram[0][i-1] + histogram[0][i];
      histogram[1][i] = histogram[1][i-1] + histogram[1][i];
      histogram[2][i] = histogram[2][i-1] + histogram[2][i];
    }

  return histogram;
}
